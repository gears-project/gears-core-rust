use xfstruct::{XFlowValue};

pub expression -> XFlowValue
  = boolean_expression
  / arithmetic_expression
  / atom

// Arithmetic

pub arithmetic_expression -> XFlowValue
  = e:arithmetic { XFlowValue::Integer(e) }

pub arithmetic -> i64 = #infix<integer> {
	#L x "+" y { x + y }
	   x "-" y { x - y }
	#L x "*" y { x * y }
	   x "/" y { x / y }
	#R x "^" y { x.pow(y as u32) }
}

// Boolean

pub boolean_expression -> XFlowValue
  = e:boolean_test { XFlowValue::Boolean(e) }

boolean_test -> bool
  = equals
  / not_equals
  / greater_than
  / less_than
  / greater_or_equal
  / less_or_equal
  / and
  / or
  / not
  / xor

equals -> bool
  = l:integer _ "==" _ r:integer { l == r }
  / l:boolean _ "==" _ r:boolean { l == r }

not_equals -> bool
  = l:integer _ "!=" _ r:integer { l != r }
  / l:boolean _ "!=" _ r:boolean { l != r }

greater_than -> bool
  = l:integer _ ">" _ r:integer { l > r }

less_than -> bool
  = l:integer _ "<" _ r:integer { l < r }

greater_or_equal -> bool
  = l:integer _ ">=" _ r:integer { l >= r }

less_or_equal -> bool
  = l:integer _ "<=" _ r:integer { l <= r }

and -> bool
  = l:boolean _ "&&" _ r:boolean { l && r }

or -> bool
  = l:boolean _ "||" _ r:boolean { l || r }

xor -> bool
  = l:boolean _ "^" _ r:boolean { l && r }

not -> bool
  = "!" l:boolean { !l }

// Primitives

atom -> XFlowValue
 = i:integer { XFlowValue::Integer(i) }
 / b:boolean { XFlowValue::Boolean(b) }

boolean -> bool
 = b:"true" { true }
 / b:"false" { false }

integer -> i64
  = n:$([0-9]+) { n.parse().unwrap() }


pub variables -> Vec<String>
  = variable*

variable -> String
  = "+" s:$([A-Za-z]+) { s.to_string() }

space -> ()
  = " "
  / "\n"
  / "\r"

_ = space*

