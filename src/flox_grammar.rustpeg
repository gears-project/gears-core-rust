use xfstruct::{XFlowValue};
use xfstate::{XFState};

#![arguments(context: &XFState)]

pub expression -> XFlowValue
  = parenthesized<expression>
  / variable
  / arithmetic_expression
  / boolean_expression
  / atom

parenthesized<foo>
  = "(" s:foo ")" { s }

// Arithmetic

pub arithmetic_expression -> XFlowValue
  = e:arithmetic { XFlowValue::Integer(e) }

pub arithmetic -> i64
    = #infix<integer> {
        #L x plus y { x + y }
           x minus y { x - y }
        #L x times y { x * y }
           x division y { x / y }
        #R x power y { x.pow(y as u32) }
    }

// Boolean

pub boolean_expression -> XFlowValue
  = e:boolean_test { XFlowValue::Boolean(e) }

boolean_test -> bool
  = boolean_result
  / boolean

boolean_result -> bool
  = not
  / l:integer eq r:integer { l == r }
  / l:integer ne r:integer { l != r }
  / l:integer gt r:integer { l > r }
  / l:integer lt r:integer { l < r }
  / l:integer gte r:integer { l >= r }
  / l:integer lte r:integer { l <= r }
  / #infix<boolean> {
      #L l eq r { l == r }
         l ne r { l != r }
      #R l and r { l && r }
         l or r { l || r }
  }

// Operators

plus -> ()
 = _ "+" _

minus -> ()
 = _ "-" _

times -> ()
 = _ "*" _

division -> ()
 = _ "/" _

power -> ()
 = _ "^" _

eq -> ()
 = _ "==" _

ne -> ()
 = _ "!=" _

gt -> ()
 = _ ">" _

lt -> ()
 = _ "<" _

gte -> ()
 = _ ">=" _

lte -> ()
 = _ "<=" _

and -> ()
 = _ "&&" _

or -> ()
 = _ "||" _

not -> bool
  = "!" l:boolean { !l }

// Primitives

atom -> XFlowValue
 = i:integer { XFlowValue::Integer(i) }
 / b:boolean { XFlowValue::Boolean(b) }

boolean -> bool
 = "true" { true }
 / "false" { false }

integer -> i64
  = n:$([0-9]+) { n.parse().unwrap() }

variable -> XFlowValue
 = "$" s:$([A-Za-z]+) {?
    match context.get(s) {
        Some(val) => Ok(val.value.to_owned()),
        None => Err("Value not found in local state")
    }
}

boolean_variable -> bool
 = "$" s:$([A-Za-z]+) {?
    match context.get(s) {
        Some(val) => {
            match val.value {
                XFlowValue::Boolean(b) => Ok(b),
                _ => Err("Incorrect Value Found")
            }
        }
        None => Err("Value not found in local state")
    }
}

integer_variable -> i64
 = "$" s:$([A-Za-z]+) {?
    match context.get(s) {
        Some(val) => {
            match val.value {
                XFlowValue::Integer(i) => Ok(i),
                _ => Err("Incorrect Value Found")
            }
        }
        None => Err("Value not found in local state")
    }
}

space -> ()
  = " "
  / "\n"
  / "\r"

_ = space*

